## **Вопросы и краткий конспект**   

**Опции JVM**  
 * -XX:AutoBoxCacheMax=size (def 128) - увеличивает диапозон кэшируемых значений.
 * -XX:+OptimizeStringConcat (def off) - оптимизирует выделение памяти при многократной конкатенации (память выделяется только 1 раз) -> StringBuilder().append(...).toString()
* -XX:+UseCompressedStrings (def off) - включает сжатие строк (UTF-16 в ASCII). Минус - тратится время на контроль типов.  
* -XX:+UseCompressedOops (def on) - включить использование сжатых указателей (64 -> 32 бита), размер хипа равен 32 Гб (при выравнивании 8 байт). Уменьшает потребление памяти на 20-60%.  
* -XX:+UseStringCache - перед созданием строки пытается взять её из кэша. В jvm8 используются стандартно.  
* -Xmx1024M size(K,M,G) (def 75% of system memory up 2Gb)- максимальный размер хипа.  
* -Xss512K size(K,M,G) (def 128 KB win86-64) - максимальный размер стека вызовов метода.
* -Dfile.encoding=UTF-8 (depends on operation system and locale) - меняет системную кодировку на UTF-8.

**Общие вопросы**
* По null-ссылке можно вызывать статические методы. null это ключевое слово, не объект и не тип. null instanceOf Class -> false. Можно передавать в методы - print (null).
* String a = "Hello" (в пуле). String b = new String ("Hello") - в хипе. lo = "lo"; Hello = "Hel" + lo; -> false. Так конкатенация происходит в runtime, а не в compile time (как тут Hello ="Hel" +"lo").
* Отличия интерфейсов (множественная реализация, private static константы) от абстрактных классов (одиночное наследование, могут хранить изменяемые переменные)
* Ключевое слово "this" для анонимных классов указывает на экземпляр самого себя, а для лямбд на место откуда они вызваны (на экземпляр класса или .class, если из статического метода?)
* Функциональные интерфейсы - Runnable, ActionListener, Callable, Comparator (etc). Marker интерфейсы -Cloneable, Serializable, EventListener, Remote.
* Методы определенные в иерархии класса сильнее default-методов интерфейсов с той же сигнатурой.
* Static методы в интерфейсах не наследуются классом или интерфейсом, доступ к методу можно получить только по имени интерфейса.
* Static и default методы в интерфейсах не могут иметь методы с сигнатурой методов Object, так как всегда будут неактуальны (compile error)
* Package-privite - модификатор для класса по умолчанию. Доступ к private полям родителя, доступен только для потомков в том же package.
* Static поля не потокобезопасны, одно из решений проблемы делать поля константами.
* При передачи объекта в метод (перезгрузка, final, private -> раннее связывание), выбор метода определяется типом ссылки.
* При десериализации transient поля получаются значения по умолчанию, static тоже, но только если в области видимости нет объектов своего типа (тогда он получит их значение). Значения полей берутся из потока, конструктор не вызывается.
* При наследовании методы выбрасыют нерасширяющие исключения, если конструктор вызывает конструктор родителя с исключениями, то он должен выбрать несужающие исключения. При исключении в конструкторе объект не будет создан.

**Оптимизация и рефакторинг**
* Избегать перегрузок методов (усложняют понятность кода), перегруженные методы должны нести одинаковую функциональность, вызывать перегруженные методы через другие (принцип DRY).
* Классы-обертки примитивных типов иммутабельны -> при boxing (если не из пула) создается новый объект, что приводит к неразумному расходованию памяти. Большинство операторов применимы только к примитивам, что приводит к autoboxing->boxing.
